CREATE OR REPLACE PACKAGE  BODY  pkg_sched_job AS

PROCEDURE create_job_using_stp 
( job_name VARCHAR2 DEFAULT NULL -- system can generated job name
 ,job_description VARCHAR2 DEFAULT NULL 
 ,proc_owner VARCHAR2
 ,package_name VARCHAR2 DEFAULT NULL 
 ,procedure_name VARCHAR2 
 ,subprogram_id NUMBER DEFAULT 1
 ,start_at DATE DEFAULT SYSDATE 
 ,procedure_args_json VARCHAR2 DEFAULT NULL
)
AS
BEGIN 
NULL;
END create_job_using_stp;

PROCEDURE gen_plsql_call
( owner VARCHAR2
 ,package_name VARCHAR2 DEFAULT NULL 
 ,procedure_name VARCHAR2 
 ,subprogram_id NUMBER DEFAULT 1
   ,call_code OUT VARCHAR2 
) 
AS
BEGIN 
NULL;
END gen_plsql_call;

PROCEDURE create_chain
( chain_info_json VARCHAR2 
) AS 
  lt_steps sys.re$name_array := sys.re$name_array();
  l_chain_name  VARCHAR2( 100 );
  l_step_name   VARCHAR2( 100 );
  l_chain_owner   VARCHAR2( 100 );
  l_proc_full_name    VARCHAR2( 100 );
  l_owner_dot_name    VARCHAR2( 100 );
  l_chain_exist   NUMBER;
BEGIN 
/* json example:
    { chain_name: "super_chain"
     ,steps: 
        [ 
            { procedure_owner: "OwnerOne"
            , procedure_name: "magicProc  edure"
            }
            ,{ procedure_owner: "theOwner"
            , procedure_name: "funnyProcedure"
            }
        ]
     }
*/
  FOR rec IN (
    SELECT chain_name, chain_owner, step_proc_owner, step_proc_name, step_proc_pkg 
      ,rownum rnum 
    FROM JSON_TABLE (
      chain_info_json
    , '$'
    COLUMNS 
    (  chain_name VARCHAR2(30) PATH '$.chain_name'
      ,chain_owner VARCHAR2(30) PATH '$.chain_owner'
     --,steps VARCHAR2(200) FORMAT JSON PATH '$.steps' 
     ,NESTED PATH '$.steps[*]' 
        COLUMNS (
             step_proc_owner VARCHAR2(30) PATH '$.procedure_owner' 
            ,step_proc_name VARCHAR2(30) PATH '$.procedure_name' 
            ,step_proc_pkg  VARCHAR2(30) PATH '$.procedure_package' 
        )
    ) ) 
  ) LOOP  
    IF rec.rnum = 1 
    THEN
      l_chain_owner := upper( coalesce( rec.chain_owner, user ) );
      l_chain_name  := upper( rec.chain_name );
      SELECT count(1)
      INTO l_chain_exist
      FROM all_scheduler_chains
      WHERE owner = l_chain_owner
        AND chain_name = l_chain_name
      ;
      l_owner_dot_name := l_chain_owner|| '.' || l_chain_name ;
      IF l_chain_exist = 0 
      THEN
        dbms_scheduler.create_chain (  chain_name => l_owner_dot_name );
      END IF;
      -- assert that chain has no steps yet! 

    END IF; -- check chain 

      -- create step 
      l_proc_full_name := upper( 
          coalesce(rec.step_proc_owner, user) 
          ||CASE WHEN rec.step_proc_pkg IS NOT NULL THEN '.'||rec.step_proc_pkg END
          ||'.'||rec.step_proc_name 
        );
      l_step_name := 'STEP'||'_'||rec.rnum;
      dbms_scheduler.define_chain_step 
        (  chain_name => l_owner_dot_name
          ,step_name => l_step_name
          ,program_name => l_proc_full_name
        );
      lt_steps.extend();
      lt_steps( lt_steps.count ) :=  l_step_name ;

      dbms_scheduler.define_chain_rule 
        (  chain_name => l_chain_name
          ,condition  => 
            CASE WHEN rec.rnum > 1 THEN lt_steps( rec.rnum - 1 )||' ' END ||'TRUE'
          ,action     => 'START '||l_step_name
          ,rule_name  => 'chain_rule_'||rec.rnum 
          ,comments   => 'generated by '||$$plsql_name
        );
  END LOOP; -- over steps 
END create_chain;
END;
/

show errors
